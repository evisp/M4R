"""
Match4Research Recommendations API
Serves pre-computed recommendations generated by fetch_and_build.py
"""

from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from typing import Optional, List, Dict, Any
from pathlib import Path
import json
import datetime

# If project uses a config module with path constants, you can import it.
# Otherwise, defaults below will work.
try:
    import config
    PROCESSED_DIR = getattr(config, "PROCESSED_DATA_DIR", Path("data/processed"))
except Exception:
    PROCESSED_DIR = Path("data/processed")

OUTPUT_DIR = PROCESSED_DIR / "output"
RECS_FILE = OUTPUT_DIR / "recommendations.json"

app = FastAPI(
    title="Match4Research AI API",
    description="Serves AI-powered recommendations for individuals and organizations",
    version="1.1.0",
)

# CORS (adjust for production domains)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Replace with specific origins in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global in-memory cache
CACHE: Dict[str, Any] = {
    "loaded_at": None,
    "data": None,
}

def load_recommendations_file() -> Dict[str, Any]:
    if not RECS_FILE.exists():
        raise FileNotFoundError(f"Recommendations file not found at: {RECS_FILE}")

    with open(RECS_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    return data

def ensure_cache_loaded(force: bool = False) -> None:
    if force or CACHE["data"] is None:
        data = load_recommendations_file()
        CACHE["data"] = data
        CACHE["loaded_at"] = datetime.datetime.utcnow().isoformat() + "Z"

def get_all_individual_recs() -> List[Dict[str, Any]]:
    ensure_cache_loaded()
    return CACHE["data"].get("recommendations", {}).get("individuals", [])

def get_all_organization_recs() -> List[Dict[str, Any]]:
    ensure_cache_loaded()
    return CACHE["data"].get("recommendations", {}).get("organizations", [])

@app.on_event("startup")
def startup_event():
    try:
        ensure_cache_loaded(force=True)
    except FileNotFoundError:
        # Lazy load later; allows API to start even if file not yet generated
        pass

@app.get("/")
def root():
    return {
        "service": "Match4Research AI API",
        "version": "1.1.0",
        "routes": {
            "health": "/health",
            "reload": "/admin/reload",
            "individual_recs": "/api/recommendations/individual/{individual_id}",
            "organization_recs": "/api/recommendations/organization/{organization_id}",
            "all_individuals": "/api/recommendations/individuals",
            "all_organizations": "/api/recommendations/organizations",
            "stats": "/api/statistics",
        },
    }

@app.get("/health")
def health():
    try:
        ensure_cache_loaded()
        meta = CACHE["data"].get("metadata", {})
        return {
            "status": "ok",
            "loaded_at": CACHE["loaded_at"],
            "file_path": str(RECS_FILE),
            "totals": {
                "individuals": meta.get("total_individuals", 0),
                "organizations": meta.get("total_organizations", 0),
                "projects": meta.get("total_projects", 0),
                "top_k_per_entity": meta.get("top_k_per_entity"),
            },
        }
    except FileNotFoundError:
        return {
            "status": "missing",
            "message": f"Recommendations file not found at {RECS_FILE}",
        }

@app.post("/admin/reload")
def admin_reload():
    ensure_cache_loaded(force=True)
    meta = CACHE["data"].get("metadata", {})
    return {
        "status": "reloaded",
        "loaded_at": CACHE["loaded_at"],
        "totals": {
            "individuals": meta.get("total_individuals", 0),
            "organizations": meta.get("total_organizations", 0),
            "projects": meta.get("total_projects", 0),
        },
    }

@app.get("/api/statistics")
def get_statistics():
    ensure_cache_loaded()
    data = CACHE["data"]
    return {
        "success": True,
        "metadata": data.get("metadata", {}),
        "statistics": data.get("statistics", {}),
    }

@app.get("/api/recommendations/individual/{individual_id}")
def get_individual_recommendations(
    individual_id: str,
    top_k: Optional[int] = Query(None, ge=1, le=100, description="Limit number of recommendations"),
):
    ensure_cache_loaded()
    individuals = get_all_individual_recs()
    item = next((i for i in individuals if i.get("individual_id") == individual_id), None)
    if not item:
        raise HTTPException(status_code=404, detail=f"Individual {individual_id} not found")

    if top_k is not None:
        recs = item.get("recommendations", [])[:top_k]
        item = {
            **item,
            "recommendations": recs,
            "match_count": len(recs),
        }

    return {"success": True, "data": item}

@app.get("/api/recommendations/organization/{organization_id}")
def get_organization_recommendations(
    organization_id: str,
    top_k: Optional[int] = Query(None, ge=1, le=100, description="Limit number of recommendations"),
):
    ensure_cache_loaded()
    orgs = get_all_organization_recs()
    item = next((o for o in orgs if o.get("organization_id") == organization_id), None)
    if not item:
        raise HTTPException(status_code=404, detail=f"Organization {organization_id} not found")

    if top_k is not None:
        recs = item.get("recommendations", [])[:top_k]
        item = {
            **item,
            "recommendations": recs,
            "match_count": len(recs),
        }

    return {"success": True, "data": item}

@app.get("/api/recommendations/individuals")
def list_all_individual_recommendations(
    top_k: Optional[int] = Query(None, ge=1, le=100),
    limit_entities: Optional[int] = Query(None, ge=1, le=1000, description="Limit number of entities returned"),
):
    ensure_cache_loaded()
    individuals = get_all_individual_recs()
    if limit_entities is not None:
        individuals = individuals[:limit_entities]

    if top_k is not None:
        trimmed = []
        for item in individuals:
            recs = item.get("recommendations", [])[:top_k]
            trimmed.append({
                **item,
                "recommendations": recs,
                "match_count": len(recs),
            })
        individuals = trimmed

    return {"success": True, "count": len(individuals), "data": individuals}

@app.get("/api/recommendations/organizations")
def list_all_organization_recommendations(
    top_k: Optional[int] = Query(None, ge=1, le=100),
    limit_entities: Optional[int] = Query(None, ge=1, le=1000),
):
    ensure_cache_loaded()
    orgs = get_all_organization_recs()
    if limit_entities is not None:
        orgs = orgs[:limit_entities]

    if top_k is not None:
        trimmed = []
        for item in orgs:
            recs = item.get("recommendations", [])[:top_k]
            trimmed.append({
                **item,
                "recommendations": recs,
                "match_count": len(recs),
            })
        orgs = trimmed

    return {"success": True, "count": len(orgs), "data": orgs}

# simple ping to verify server is alive
@app.get("/ping")
def ping():
    return {"pong": True}
